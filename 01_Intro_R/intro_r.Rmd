---
title: 'R Bootcamp'
output: html_document
---

# Introduction to R

In this course we will be using the
[R software environment](https://cran.r-project.org/) for all our
analysis. Throughout the course you will learn R and data analysis techniques simultaneously. However, we need to introduce basic R syntax to get you going. In this section, rather than cover every R skill you need, we introduce just enough so that you can follow along the remaining sections where we provide more in-depth coverage, building upon what you learn in this section. We find that we better retain R knowledge when we learn it to solve a specific problem.

In this section, as done throughout the course, we will use a motivating case study. We ask a specific question related to crime in the United States and provide a relevant dataset. Some basic R skills will permit us to answer the motivating question. 


## US gun murders

Imagine you live in Europe and are offered a job at a US company with many locations across all states. It is a great job but news with headlines such as [**America is one of 6 countries that make up more than half of guns deaths worldwide**](https://www.vox.com/2018/8/29/17792776/us-gun-deaths-global) have you worried. Charts like this make you worry even more:

![US gun homicides chart](http://abcnews.go.com/images/International/homocides_g8_countries_640x360_wmain.jpg)

Or even worse, this version from [everytown.org](https://everytownresearch.org/gun-violence-america/):

![US gun homicides second chart](https://everytownresearch.org/wp-content/uploads/2016/07/GunTrends_murders_per_1000.png)

But then you are reminded that the US is a large and diverse country with 50 very different states as well as the District of Columbia (DC). 

California, for example, has a larger population than Canada and 20 US states have populations larger than that of Norway. In some respects the variability across states in the US is akin to the variability across countries in Europe. Furthermore, although not in the charts above, the murder rates in Lithuania, Ukraine, and Russia are higher than 4 per 100,000. So perhaps the news reports that worried you are too superficial. You have options of where to live and want to find out how safe each state is. We will gain some insights by examining data related to gun homicides in the US using R. 

Now before we get started with our example, we need to cover logistics as well as some of the very basic building blocks that we need to gain more advanced R skills. Be aware that for some of these, it is not immediately obvious how it is useful, but later in the book you will appreciate having the knowledge under your belt.


## Data types

Variables in R can be of different types. For example, we need to distinguish numbers from character strings and tables from simple lists of numbers. The function `class` helps us determine what type of object we have:

```{r}
a <- 2
class(a)
```

```{r}
b <- "hello"
class(b)
```


To work efficiently in R it is important to learn the different types of variables and what we can do with these.

### Data Frames

Up to now, the variables we have defined are just one number. This is not very useful for storing data. The most common way of storing a dataset in R is in a _data frame_. Conceptually, we can think of a data frame as a table with rows representing observations and the different variables reported for each observatin defining the columns. Data frames are particularly useful for datasets because we can combine different data types into one object. 

We stored the data for our motivating example in a data frame. You can access this dataset by loading the `dslabs` library and loading the `murders` dataset using the `data` function:

```{r}
library(dslabs)
data(murders)
head(murders)
```

To see that this is in fact a data frame we type

```{r}
class(murders)
```

### Examining an object

The function `str` is useful to find out more about the structure of an object

```{r}
str(murders)
```

This tells us much more about the object. We see that the table has 51 rows (50 states plus DC) and five variables. We can show the first six lines using the function `head`:

```{r}
head(murders)
```

In this dataset each state is considered an observation and five variables are reported for each state.

Before we go any further in answering our original question about different states, let's get to know the components of this object better.

### The accessor

For our analysis we will need to access the different variables, represented by columns, included in this data frame. To access these variables we use the accessor operator `$` in the following way:

```{r}
murders$population
```

But how did we know to use `population`? Above, by applying the function `str` to the obejct `murders`, we revealed the names for each of the five variables stored in this table. We can quickly access the variables names using:

```{r}
names(murders)
```

It is important to know that the order of the entries in `murders$population` preserve the order of the rows in our data table. This will later permit us to manipulate one variable based on the results of another. For example, we will be able to order the state names by number of murders.

**Tip**: R comes with a very nice auto-complete functionality that saves us the trouble of typing out all the names. Try typing `murders$p` then hitting the _tab_ key on your keyboard. RStudio has many useful auto-complete feature options.

### Vectors: numerics, characters, and logical

Note that the object `murders$population` is not one number but several. We call these types of objects _vectors_. A single number is technically a vector but in general vectors refer to objects with several entries. The function `length` tells you how many entries are in the vector:

```{r}
pop <- murders$population
length(pop)
```

This particular vector is _numeric_ since population sizes are numbers:

```{r}
class(pop)
```
In a numeric vector, every entry must be a number. 

To store character strings, vectors can also be of class _character_. For example, the state names are characters:

```{r}
class(murders$state)
```

As with numeric vectors, all entries in a character vector need to be a character.

Another important type  are _logical vectors_. These must be either `TRUE` or `FALSE`. 

```{r}
z <- 3 == 2
z
class(z)
```

Here the `==` is a relational operator asking if 3 is equal to 2. Remember that in R, if you just use one `=` when you actually assign avalue. You can see the other _relational operators_ by typing

```{r, eval=FALSE}
?Comparison
```

In future sections you will see how useful relational operators can be.


### Factors

In the `murders` dataset we might expect the region to also be a character vector. However, it is not:

```{r}
class(murders$region)
```

it is a _factor_. Factors are useful for storing categorical data. Notice that there are only 4 regions:


```{r}
levels(murders$region)
```

So, in the background, R stores these _levels_ as integers and keeps a map to keep track of the labels. This is more memory efficient than storing all the characters. However, factors are also a source of confusion as they can easily be confused with characters but behave differently in different contexts. We will see more of this later. 

In general, we recommend avoiding factors as much as possible although they are sometimes necessary to fit models containing categorical data.
 

## Vectors

The most basic unit available in R to store data are _vectors_. Complex datasets can usually be broken down into components that are vectors. For example, in a data frame, each column is a vector. Here we learn more about this important class.

### Creating vectors

We can create vectors using the function `c`, which stands for concatenate. We use `c` to _concatenate_ entires in the following way:

```{r}
codes <- c(380, 124, 818)
codes
```

We can also create character vectors. We use the quotes to denote that the entries are characters rather than variables names.

```{r}
country <- c("italy", "canada", "egypt")
country
```

Note that if you type

```{r, eval=FALSE}
country <- c(italy, canada, egypt)
```
you recieve an error becuase the variables `italy`, `canada` and `egypt` are not defined: R looks for variables with those names and returns an error.

### Names

Sometimes it is useful to name the entries of a vector. For example, when defining a vector of country codes we can use the names to connect the two:

```{r}
codes <- c(italy = 380, canada = 124, egypt = 818)
codes
```

The object `codes` continues to be a numeric vector:
```{r}
class(codes)
```

but with names
```{r}
names(codes)
```

If the use of strings without quotes looks confusing, know that you can use the quotes as well

```{r}
codes <- c("italy" = 380, "canada" = 124, "egypt" = 818)
codes
```

There is no difference between this call and the previous one: one of the many ways R is quirky compared to other languages.

We can also assign names using the `names` function:

```{r}
codes <- c(380, 124, 818)
country <- c("italy","canada","egypt")
names(codes) <- country
codes
```

### Sequences

Another useful function for creating vectors generates sequences

```{r}
seq(1, 10)
```

The first argument defines the start, and the second the end. The default is to go up in increments of 1, but a third argument let's us tell it how much to jump by:

```{r}
seq(1, 10, 2)
```

If we want consecutive integers we can use the following shorthand

```{r}
1:10
```

Note that when we use this function, R produces integers, not numerics, because they are typically used to index something:

```{r}
class(1:10)
```

However, note that as soon as we create something that's not an integer the class changes:

```{r}
class(seq(1, 10))
class(seq(1, 10, 0.5))
```

### Subsetting

We use square brackets to access specific elements of a list. For the vector `codes` we defined above, we can access the second element using
```{r}
codes
codes[2]
```

You can get more than one entry by using a multi-entry vector as an index:
```{r}
codes[c(1,3)]
```

The sequences defined above are particularly useful if we want to access, say, the first two elements

```{r}
codes[1:2]
```

If the elements have names, we can also access the entries using these names. Here are two examples.

```{r}
codes["canada"]
codes[c("egypt","italy")]
```

### Coercion

In general, _coercion_ is an attempt by R to be flexible with data types. When an entry does not match the expected, R tries to guess what we meant before throwing an error. This can also lead to confusion. Failing to understand _coercion_ can drive a programmer crazy when attempting to code in R since it behaves quite diffently from most other languages in this regard. Let's learn about it with some examples.

We said that elements of a vector must be all of the same type. So if we try to combine, say, numbers and characters you might expect an error

```{r}
x <- c(1, "canada", 3)
```

But we don't get one, not even a warning! What happened? Look at `x` and its class:

```{r}
x
class(x)
```

R _coerced_ the data into characters. It guessed that because you put a character string in the vector you meant the 1 and 3 to actually be character strings `"1"` and `"3"`. The fact that not even a warning is issued is an example of how coercion can cause many unnoticed errors in R. 

R also offers functions to force a specific coercion. For example you can turn numbers into characters with 

```{r}
x <- 1:5
y <- as.character(x)
y
```

And you can turn it back with `as.numeric`. 

```{r}
as.numeric(y)
```
 
This function is actually quite useful as datasets that include numbers as character strings are common. 

### Not Availables (NA)

When these coercion functions encounter an impossible case it gives us a warning and turns the entry into a special value called an `NA` for "not available".  For example:

```{r}
x <- c("1", "b", "3")
as.numeric(x)
```

R does not have any guesses for what number you want when you type `b` so it does not try.

Note that as a data scientist you will encounter `NA`s often as they are used for missing data, a common problem in real-life datasets.


## Sorting

Now that we have some basic R knowledge under our belt, let's try to gain some insights into the safety of different states in the context of gun murders. 

### `sort` 

We want to rank the states from least to most gun murders. The function `sort` sorts a vector in increasing order. So we can see the number of gun murders by typing 

```{r}
sort(murders$total)
```

However, this does not give us information about which states have which murder totals. For example, we don't know which state had `r max(murders$total)` murders in 2010. 

### `order`

The function `order` is closer to what we want. It takes a vector and returns the vector of indexes that sort the input vector. This may sound confusing so let's look at a simple example: we create a vector and sort it:

```{r}
x <- c(31, 4, 15, 92, 65)
sort(x)
```

Rather than sort the vector, the function `order` gives us back the index that, if used to index the vector, will sort it:

```{r}
index <- order(x)
x[index]
```

If we look at this index we see why it works:
```{r}
x
order(x)
```

Note that the second entry of `x` is the smallest so `order(x)` starts with `2`. The next smallest is the third entry so the second entry is `3` and so on. 

How does this help us order the states by murders? First remember that the entries of vectors you access with `$` follow the same order as the rows in the table. So, for example, these two vectors, containing the state names and abbreviations respectively, are matched by their order:

```{r}
murders$state[1:10]
murders$abb[1:10]
```

So this means we can now order the state names by their total murders by first obtaining the index that orders the vectors according to murder totals, and then indexing the state names or abbreviation vector:

```{r}
ind <- order(murders$total) 
murders$abb[ind] 
```

We see that California had the most murders.

### `max` and `which.max`

If we are only interested in the entry with the largest value we can use `max` for the value

```{r}
max(murders$total)
```

and `which.max` for the index of the largest value

```{r}
i_max <- which.max(murders$total)
murders$state[i_max]
```

For the minimum we can use `min` and `which.min` in the same way.

So is California the most dangerous state? In a next section we argue that we should be considering rates not totals. Before doing that we introduce one last order related function: `rank`


## Vector arithmetic

California had the most murders. But does this mean it is the most dangerous state? What if it just has many more people than any other state? We can very quickly confirm that, indeed, California has the largest population:

```{r}
murders$state[which.max(murders$population)]
```

with over `r floor(max(murders$population)/10^6)` million inhabitants! It is therefore unfair to compare the totals if we are interested in learning how safe the state is.

What we really should be computing is the murders per capita. The reports we describe in the motivating section used murders per 100,000 as the unit. To compute this quantiy, the powerful vector arithmetic capabilities of R come in handy.

### Rescaling

In R, arithmetic operations on vectors occur _element wise_. For a quick example suppose we have height in inches

```{r}
heights <- c(69, 62, 66, 70, 70, 73, 67, 73, 67, 70)
```
and want to covert to centimeters. Note what happens when we multiply `heights` by 2.54:

```{r}
heights * 2.54
```

it multiplied each element by 2.54.  Similarly if we want to compute how many inches taller or shorter than the average, 69 inches, we can subtract it from every entry like this

```{r}
heights - 69
```


### Two vectors

If we have two vectors of the same length, and we sum them in R, they get added entry by entry like this

$$
\begin{pmatrix}
a\\
b\\
c\\
d
\end{pmatrix}
+
\begin{pmatrix}
e\\
f\\
g\\
h
\end{pmatrix}
=
\begin{pmatrix}
a +e\\
b + f\\
c + g\\
d + h
\end{pmatrix}
$$

The same holds for other mathematical operations such as `-`, `*` and `/`.

This implies that to compute the murder rates we can simply type

```{r}
murder_rate <- murders$total / murders$population * 100000
```

Once we do this, we notice that California is no longer near the top of the list. In fact, we can use what we have learned to order the states by murder rate:

```{r}
murders$state[order(murder_rate)]
```

Note that the states are listed in *ascending* order of murder rate. Thus, DC has the highest murder rate.




## Indexing

R provides a powerful and convenient way of indexing vectors. We can, for example, subset a vector based on properties of another vector. We continue our US murders example to demonstrate.

### Subsetting with logicals

We can calculate the murder rate using

```{r}
murder_rate <- murders$total / murders$population * 100000 
```

Say you are moving from Italy where, according to an ABC news report, the murder rate is only 0.71 per 100,000. You would prefer to move to a state with a similar rate. Another powerful feature of R is that we can we can use logicals to index vectors. 
Note that if we compare a vector to a single number, it actually performs the test for each entry. Here is an example related to the question above.

```{r}
ind <- murder_rate < 0.71
ind
```

```{r}
sum(ind)
```


Or if we want to know if its less than or equal to we can use

```{r}
ind <- murder_rate <= 0.71
ind
```

Note that we get back a logical vector with `TRUE` for each entry smaller than or equal to 0.71. To see which states these are, we can leverage the fact that vectors can be indexed with logicals.

```{r}
murders$state[ind]
```

Note that to count how many are TRUE, the function `sum` returns the sum of the entries of a vector and logical vectors get _coerced_ to numeric with `TRUE` coded as 1 and `FALSE` as 0. Thus we can count the states using

```{r}
sum(ind)
```


### Logical Operators

Suppose we like the mountains and we want to move to a safe state in the West region of the country. We want the murder rate to be at most 1. So we want two different things to be true. Here we can use the logical operator _and_ which in R is `&`. This operation results in a true only when both logicals are true. To see this consider these examples:

```{r}
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
```

We can form two logicals:

```{r}
west <- murders$region == "West"
safe <- murder_rate <= 1
```

and we can use the `&`  to get a vector of logicals that tells us which states satisfy both of our conditions:

```{r}
ind <- safe & west
murders$state[ind]
```

### `which`

Suppose we want to look up California's murder rate. For this type of operation, it is convenient to convert vectors of logicals into indexes instead of keeping long vectors of logicals. The function `which` tells us which entries of a logical vector are TRUE. So we can type:

```{r}
ind <- which(murders$state == "California")
ind # this is the index that matches the California entry

murder_rate[ind]
```

### `%in%`

If rather than an index we want a logical that tells us whether or not each element of a first vector is in a second, we can use the function `%in%`. So, say you are not sure if Boston, Dakota and Washington are states, you can find out like this

```{r}
c("Boston", "Dakota", "Washington") %in% murders$state
```


## Basic Data Wrangling

Up to now we have been changing vectors by reordering them and subsetting them through indexing. But once we start more advanced analyses, we will want to prepare data tables for data analysis. We refer to this task as data wrangling. 
For this purpose we will introduce the `dplyr` package which provides intuitive functionality for working with tables. 

Once you install `dplyr` you can load it using 

```{r, warning=FALSE, message=FALSE}
library(dplyr)
```

This package introduces functions that perform the most common operations in data warngling and uses names for these functions that are relatively easy to remember. For example, to change the data table by adding a new column, we use `mutate`. To filter the data table to a subset of rows we use `filter` and to subset the data by selecting specific columns we use `select`. We can also perform a series of operations. For example, select and then filter, by sending the results of one function to another using what is called the _pipe operator_: `%>%`. Some details are included below. 

### Adding a column with `mutate`

We want all the necessary information for our analysis to be included in the data table. So the first task is to add the murder rate to our data frame. The function mutate takes the data frame as a first argument and the name and values of the variable in the second using the convention `name = values`. So to add murder rate we use:
 
```{r,message=FALSE}
murders <- mutate(murders, murder_rate = total / population * 100000)
```

Note that here we used `total` and `population` in the function, which are objects that are **not** defined in our workspace. What is happening is that `mutate` knows to look for these variables in the `murders` data frame because the first argument we put was the `murders` data frame. So the intuitive line of code above does exactly what we want. We can see the new column is added:

```{r}
head(murders)
```

Also note that we have over-written the original `murders` object. However, this does *not* change the object that is saved and loaded with `data(murders)`. If we load the `murders` data again, the original will over-write our mutated version.

Note: If we reload the dataset from the `dslabs` package it will rewrite our new data frame with the original.

### Subsetting with `filter`

Now suppose that we want to filter the data table to only show the entries for which the murder rate is lower than 0.71. To do this we use the `filter` function which takes the data table as an argument and then the conditional statement as the next argument. Like mutate, we can use the data table variable names inside the function and it will know we mean the columns and not objects in the workspace.

```{r}
filter(murders, murder_rate <= 0.71)
```


### Selecting columns with `select`

Although our data table only has six columns, some data tables include hundreds. If we want to view just a few, we can use the `select` function. In the code below we select three columns, assign this to a new object and then filter the new object: 

```{r}
new_table <- select(murders, state, region, murder_rate)
filter(new_table, murder_rate <= 0.71)
```

Note that in the call to `select`, the first argument, `murders`, is an object but `state`, `region`, and `murder_rate` are variable names. 

### The pipe: `%>%`

In the code above we wanted to show the three variables for states that have murder rates below 0.71. To do this we defined an intermediate object. In `dplyr` we can write code that looks more like our description of what we want to: 

>> original data $\rightarrow$ select $\rightarrow$ filter

For such an operation, we can use the pipe `%>%`. The code looks like this:

```{r}
murders %>% select(state, region, murder_rate) %>% filter(murder_rate <= 0.71)
```

This line of code is equivalent to the two lines of code above. Note that when using the pipe we no longer need to specify the murders data frame since the `dplyr` functions assume that whatever is being _piped_ is what should be operated on.

## Summarizing data with `dplyr`

An important part of exploratory data analysis is summarizing data. It is sometimes useful to split data into groups before summarizing. 

### Summarize

The `summarize` function in `dplyr` provides a way to compute summary statistics with intuitive and readable code. We can compute the average of the murder rates like this.


```{r}
murders %>% summarize(avg = mean(murder_rate))
```

However, note that the US murder rate is **not** the average of the state murder rates. Because in this computation the small states are given the same weight as the large ones. The US murder rate is proportional to the total US murders divided by the total US population.

To compute the country's average murder rate using the `summarize` function, we can do the following: 

```{r}
us_murder_rate <- murders %>% 
  summarize(murder_rate = sum(total) / sum(population) * 100000)

us_murder_rate
```


This computation counts larger states proportionally to their size and this results in a larger value.

### Using the dot to access the piped data 

The `us_murder_rate` object defined above represents just one number. Yet we are storing it in a data frame

```{r}
class(us_murder_rate)
```

since, as with most `dplyr` functions, `summarize` *always returns a data frame*.

This might be problematic if we want to use the result with functions that require a numeric value. Here we show a useful trick to access values stored in data piped via `%>%`: when a data object is piped it can be accessed using the dot `.`. To understand what we mean take a look at this line of code:

```{r}
us_murder_rate %>% .$murder_rate
```

Note that this returns the value in the `murder_rate` column of `us_murder_rate` making it equivalent to `us_murder_rate$murder_rate`. To understand this line, you just need to think of `.` as a placeholder for the data that is being passed through the pipe. Because this data object is a data frame, we can access it's columns with the `$`. 

To get a number from the original data table with one line of code we can type:

```{r}
us_murder_rate <- murders %>% 
  summarize( murder_rate = sum(total) / sum(population) * 100000) %>%
  .$murder_rate

us_murder_rate
```

which is now a numeric:

```{r}
class(us_murder_rate)
```

We will see other instances in which using the `.` is useful. For now, we will only use it to produce numeric vectors from pipelines constructed with `dplyr`.

### Group then summarize

A common operation in data exploration is to first split data into groups and then compute summaries for each group. For example, we may want to compute the median murder rate for each region. The `group_by` function helps us do this. 

If we type this:

```{r}
murders %>% 
  group_by(region) %>%
  summarize(median_rate = median(murder_rate),
            mean_rate = mean(murder_rate))
```

we get a table with the median murde rate for each of the four regions.

### Sorting data tables

When examining a dataset it is often convenient to sort the table by the different columns. We know about the `order` and `sort` functions, but for ordering entire tables, the `dplyr` function `arrange` is useful. For example, here we order the states by population size:

```{r}
murders %>% 
  arrange(population) %>% 
  head()
```

Note that we get to decide which column to sort by. To see the states by murder rate, from smallest to largest, we arrange by `murder_rate` instead:

```{r}
murders %>% 
  arrange(murder_rate) %>% 
  head()
```

Note that the default behavior is to order in ascending order. In `dplyr`, the function `desc` transforms a vector to be in descending order. So if we want to sort the table in descending order we can type

```{r}
murders %>% 
  arrange(desc(murder_rate)) %>% 
  head()
```

#### Nested Sorting

If we are ordering by a column with ties we can use a second column to break the tie. Similarly, a third column can be used to break ties between the first and second and so on. Here we order by `region` then within region we order by murder rate:

```{r}
murders %>% 
  arrange(region, murder_rate) %>% 
  head()
```


## Basic plots

Exploratory data visualization is perhaps the strength of R. One can quickly go from idea to data to plot with a unique balance of flexibility and ease. For example, Excel may be easier than R but it is no where near as flexible. D3 may be more flexible and powerful than R, but it takes much longer to generate a plot. The next section is dedicated to this topic, but here we introduce some very basic plotting functions.

### Scatter plots

Earlier we inferred that states with larger populations are likely to have more murders. This can be confirmed with an exploratory visualization that plots these two quantities against each other:

```{r, first-plot}
population_in_millions <- murders$population/10^6
total_gun_murders <- murders$total
plot(population_in_millions, total_gun_murders)
```

We can clearly see a relationship.
**Advanced**: For a quick plot that avoids accessing variables twice, we can use the `with` function
```{r, eval=FALSE}
with(murders, plot(population, total))
```


### Histograms

We will describe histograms as they relate to distributions in the next section. Here we will simply note that histograms are a powerful graphical summary of a list of numbers that gives you a general overview of the types of values you have. We can make a histogram of our murder rates by simply typing

```{r, warning=FALSE, message=FALSE}
murders <- mutate(murders, murder_rate = total / population * 100000)
hist(murders$murder_rate)
```

We can see that there is a wide range of values with most of them between 2 and 3 and one very extreme case with a murder rate of more than 15:

```{r}
murders$state[which.max(murders$murder_rate)]
```

### Boxplot

Boxplots will be described in more detail in the next section as well. But here we say that they provide a more terse summary than the histogram - but they are easier to stack with other boxplots. Here we can use them to compare the different regions.

```{r}
boxplot(murder_rate~region, data = murders)
```

We can see that the South has larger murder rates than the other three regions.
